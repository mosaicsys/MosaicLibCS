//-------------------------------------------------------------------
/*! @file SerialIOBase.cs
 *  @brief This file contains the definitions of the base class(s) that are used by use case specific implementation objects in the SerialIO parts of this library.
 * 
 * Copyright (c) Mosaic Systems Inc.
 * Copyright (c) 2008 Mosaic Systems Inc.
 * Copyright (c) 2002 Mosaic Systems Inc.  (C++ library version: SerialPort.h, SerialPort.cpp)
 * All rights reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using System;
using System.Collections;
using System.Collections.Generic;

using MosaicLib;
using MosaicLib.Modular;
using MosaicLib.Modular.Action;
using MosaicLib.Modular.Common;
using MosaicLib.Modular.Config;
using MosaicLib.Modular.Part;
using MosaicLib.Time;
using MosaicLib.Utils;

namespace MosaicLib.SerialIO
{
	//-----------------------------------------------------------------
	#region PortBase

    /// <summary>
    /// This class is the base clase for most IPort type objects.  It implements the common logic and execution logic that all (or most) port types share.
    /// </summary>
	public abstract class PortBase : SimpleActivePartBase, IPort
	{
		//-----------------------------------------------------------------
		#region Ctor, DTor

        /// <summary>
        /// PortBase constructor.  Requires Port config and partType parameters.  
        /// Port config is usually provided by the original client while partType is generally provided by the constructor for specific class that is derived from this one.
        /// </summary>
        /// <remarks>
        /// Change the default so that SerialPort objects do not automatically flip between Busy and Idle while running commands - this will decrease the state change log rate generated by this objects.
        /// Prevent creating and publishing the base state if PortConfig does not explicilty provide a PartBaseIVI
        /// </remarks>
		protected PortBase(PortConfig config, string partType)
            : base(config.Name, partType, initialSettings: SimpleActivePartBaseSettings.DefaultVersion2.Build(disableBusyBehavior: true, maxActionsToInvokePerServiceLoop: 5, waitTimeLimit: config.SpinWaitTimeLimit, partBaseIVI: config.PartBaseIVI, disablePartBaseIVIUse : (config.PartBaseIVI == null), addSimpleActivePartBehaviorOptions: SimpleActivePartBehaviorOptions.DisableActionInfoRelatedIVAUsage))
		{ 
			portConfig = config;

            if (portConfig.PartBaseIVI != null)
                portConfig.PartBaseIVI.GetValueAccessor<string>("{0}.PortSpecStr".CheckedFormat(PartID)).Set(portConfig.SpecStr);

			Error = Log.Emitter(config.ErrorMesgType);
			Info = Log.Emitter(config.InfoMesgType);
			Debug = Log.Emitter(config.DebugMesgType);
            Trace = Log.Emitter(config.TraceMesgType);
            Logging.Logger logger = Log as Logging.Logger;
            if (logger != null)
            {
                logger.GroupName = config.LoggerGroupID;
                logger.InstanceLogGate = Logging.LogGate.Debug;     // by default only emit Debug and above messages.  Logging.Logger.[name].LogGate.Increase config key can be used to elevate this level
            }

            traceDataLogger = new Logging.Logger("{0}.Data".CheckedFormat(PartID), config.TraceDataLoggerGroupID, config.TraceDataLoggerInitialLogGate);
			TraceData = traceDataLogger.Emitter(config.TraceDataMesgType);

			BaseStateChangeEmitter = Debug;

			// make all Port actions use the given Trace, Debug and Info level for their State, Done and Error messages.
			ActionLoggingReference.State = Trace;
			ActionLoggingReference.Done = Debug;
			ActionLoggingReference.Error = Info;

            // most serial action progress messages are logged to the trace logger along with the data trace messages
            ActionLoggingConfig traceActionLoggingConfig = new ActionLoggingConfig(config.TraceActionDoneMesgType, config.TraceActionErrorMesgType, config.TraceActionStateMesgType, config.TraceActionUpdateMesgType);
            ActionLoggingTraceReference = new ActionLogging(traceDataLogger, traceActionLoggingConfig);

			BaseStatePublishedNotificationList.OnNotify += BaseStateChangedEventHandler;

			if (config.RxPacketEndStrArray.Length > 0 || config.RxPacketEndScannerDelegate != null)
			{
                slidingPacketBuffer = new SlidingPacketBuffer(config.RxBufferSize, config.RxPacketEndStrArray, config.IdleTime, stripWhitespace: config.TrimWhitespaceOnRx)
                {
                    DiscardWhitespacePackets = config.DiscardWhitespacePacketsOnRx,
                };

                if (config.RxPacketEndScannerDelegate != null)
                {
                    slidingPacketBuffer.PacketEndScannerDelegate = config.RxPacketEndScannerDelegate;
                }

                if (slidingPacketBuffer.DetectWhitespace != config.DetectWhitespace)
                {
                    if (config.DetectWhitespace)
                        slidingPacketBuffer.DetectWhitespace = true;
                    else if (!config.TrimWhitespaceOnRx && !config.DiscardWhitespacePacketsOnRx && config.RxPacketEndScannerDelegate != null)
                        slidingPacketBuffer.DetectWhitespace = false;
                }
			}

            IConfig iConfig = portConfig.IConfig;

            TraceDataFormat fallbackDataFormat = ((config.RxPacketEndStrArray.Length > 0) ? TraceDataFormat.DefaultAsciiV2 : TraceDataFormat.DefaultBinaryV2);
            TraceDataEvent fallbackEventMask = (HasSlidingBuffer ? TraceDataEvent.DefaultPacketV2 : TraceDataEvent.DefaultBinaryV2);
            char fallbackAsciiEscapeChar = '&';     // this default value is specifically choosen to avoid overlaying the logging escape character so that we will not generally layer the escape char escaping in trace data.

            if (iConfig != null)
            {
                traceDataFormat = portConfig.TraceDataFormat
                                ?? iConfig.GetConfigKeyAccessOnce("Config.SerialIO.{0}.TraceData.Format".CheckedFormat(PartID), isOptional: true).GetValue<TraceDataFormat?>()
                                ?? iConfig.GetConfigKeyAccessOnce("Config.SerialIO.DefaultTraceDataFormat", isOptional: true).GetValue(fallbackDataFormat);
                traceDataEventMask = portConfig.TraceDataEventMask 
                                ?? iConfig.GetConfigKeyAccessOnce("Config.SerialIO.{0}.TraceData.EventMask".CheckedFormat(PartID), isOptional: true).GetValue<TraceDataEvent?>()
                                ?? iConfig.GetConfigKeyAccessOnce("Config.SerialIO.DefaultTraceDataEventMask", isOptional: true).GetValue(fallbackEventMask);
                traceDataAsciiEscapeChar = portConfig.TraceDataAsciiEscapeChar
                                ?? iConfig.GetConfigKeyAccessOnce("Config.SerialIO.{0}.TraceData.AsciiEscapeChar".CheckedFormat(PartID), isOptional: true).GetValue<char?>()
                                ?? iConfig.GetConfigKeyAccessOnce("Config.SerialIO.DefaultTraceDataAsciiEscapeChar".CheckedFormat(PartID), isOptional: true).GetValue<char>(fallbackAsciiEscapeChar);
            }
            else
            {
                traceDataFormat = portConfig.TraceDataFormat ?? fallbackDataFormat;
                traceDataEventMask = portConfig.TraceDataEventMask ?? fallbackEventMask;
                traceDataAsciiEscapeChar = portConfig.TraceDataAsciiEscapeChar ?? fallbackAsciiEscapeChar;
            }

            // threadWakeupNotifier.TraceEmitter = traceDataLogger.Trace;
		}

		#endregion

		//-----------------------------------------------------------------
		#region IPort Members

		private readonly PortConfig portConfig;

        /// <summary>Gives the port's Name which was provided as part of the PortConfig during creation of this port.</summary>
        public string Name { get { return portConfig.Name; } }
        /// <summary>Gives access to a copy of the PortConfig that was used to configured this port at creation time.</summary>
		public PortConfig PortConfig { get { return portConfig; } }

        /// <summary>structure gives information about the general behavior of this port as specified by when the port type specific derived type was constructed and was initially configured.</summary>
        protected PortBehaviorStorage PortBehavior { get; set; }

        /// <summary>Gives read-only access to the PortBehavior structure that gives information about the general behavior of this port.</summary>
        IPortBehavior IPort.PortBehavior { get { return PortBehavior; } }

        private TraceDataFormat traceDataFormat;
        private TraceDataEvent traceDataEventMask;
        private char traceDataAsciiEscapeChar;

        /// <summary>
        /// Impelmentation and storage class for IPortBehavior interface.
        /// </summary>
        public struct PortBehaviorStorage : IPortBehavior
        {
            /// <summary>Gives the DataDeliveryBehavior enum value that this port believes it implements</summary>
            public DataDeliveryBehavior DataDeliveryBehavior { get; set; }

            /// <summary>Returns true if this port's underlying engine is network based (EtherNet or WIFI, ...)</summary>
            /// <remarks>false for COM ports, true for TCP and UDP ports.</remarks>
            public bool IsNetworkPort { get; set; }

            /// <summary>Returns true if this port's DataDeliveryBehavior is ByteStream</summary>
            public bool IsByteStreamPort { get { return DataDeliveryBehavior == DataDeliveryBehavior.ByteStream; } }
            /// <summary>Returns true if this port's DataDeliveryBehavior is Datagram</summary>
            public bool IsDatagramPort { get { return DataDeliveryBehavior == DataDeliveryBehavior.Datagram; } }
            /// <summary>Returns true if this port generally initiates the connection to the transport medium</summary>
            public bool IsClientPort { get; set; }
            /// <summary>Returns true if this port generally accepts connections from the transport medium</summary>
            public bool IsServerPort { get; set; }
        }

        /// <summary>Defines the implementation type for an IReadAction</summary>
		protected class ReadAction : ActionImplBase<ReadActionParam, NullObj>, IReadAction
		{
            /// <summary>Only constructor</summary>
			public ReadAction(ActionQueue actionQ, ReadActionParam param, FullActionMethodDelegate<ReadActionParam, NullObj> method, ActionLogging loggingReference)
                : base(actionQ, param, false, method, loggingReference) 
			{ }
		}

        /// <summary>Returns an IReadAction which refers to the given ReadActionParam instance and which may be used to execute a read using the ReadActionParam defined behavior</summary>
        /// <remarks>This may not be used with Port's that have been configured to use an internal sliding buffer.  Use CreateGetnextPacketAction instead in these cases.</remarks>
        public IReadAction CreateReadAction(ReadActionParam param)
		{
            param = param ?? new ReadActionParam();
            return new ReadAction(actionQ, param, PerformReadAction, new ActionLogging("Read", ActionLoggingTraceReference));
		}

        /// <summary>Defines the implementation type for an IWriteAction</summary>
        protected class WriteAction : ActionImplBase<WriteActionParam, NullObj>, IWriteAction
		{
            /// <summary>Only constructor</summary>
            public WriteAction(ActionQueue actionQ, WriteActionParam param, FullActionMethodDelegate<WriteActionParam, NullObj> method, ActionLogging loggingReference)
                : base(actionQ, param, false, method, loggingReference) 
			{ }
		}

        /// <summary>Returns an IWriteAction which refers to the given WriteActionParam instance and which may be used to execute a write using the WriteActionParams defined behavior</summary>
        public IWriteAction CreateWriteAction(WriteActionParam param)
		{
            param = param ?? new WriteActionParam();
            return new WriteAction(actionQ, param, PerformWriteAction, new ActionLogging("Write", ActionLoggingTraceReference));
		}

        /// <summary>Defines the implementation type for an IFlushAction</summary>
        protected class FlushAction : ActionImplBase<TimeSpan, NullObj>, IFlushAction
		{
            /// <summary>Only constructor</summary>
            public FlushAction(ActionQueue actionQ, TimeSpan param, FullActionMethodDelegate<TimeSpan, NullObj> method, ActionLogging loggingReference)
                : base(actionQ, param, false, method, loggingReference) 
			{ }
		}

        /// <summary>Returns an IBasicAction.  Underlying action TimeSpan parameter has been initilized to given value of flushWaitTime.  This action may be used to flush the port of characters for the given wait time period.</summary>
        public IFlushAction CreateFlushAction(TimeSpan flushWaitLimit)
		{
            return new FlushAction(actionQ, flushWaitLimit, PerformFlushAction, new ActionLogging("Flush", ActionLoggingTraceReference));
		}

        /// <summary>Asynchronous property that returns true for Ports that have been configured to use a SlidingBuffer and which have at least one packet decoded from the sliding buffer</summary>
        public bool HasPacket { get { return (NumPacketsReady > 0); } }

        /// <summary>Asynchronous property that returns the number of packets that are currently available to be dequeued from the Port.  This property will only be non-zero on Ports that have been configured to use a SlidingBuffer.</summary>
        public int NumPacketsReady { get { return volatileNumberOfPacketsAvailable; } }

        /// <summary>Defines the implementation type for an IGetNextPacketAction</summary>
        protected class GetNextPacketAction : ActionImplBase<NullObj, Packet>, IGetNextPacketAction
        {
            public GetNextPacketAction(ActionQueue actionQ, FullActionMethodDelegate<NullObj, Packet> method, ActionLogging loggingReference)
                : base(actionQ, null, true, method, loggingReference)
            { }
        }

        /// <summary>Returns an IGetNextPacketAction which may be executed to attempt to dequeue the next available Packet received by the Port.</summary>
        public IGetNextPacketAction CreateGetNextPacketAction()
        {
            return new GetNextPacketAction(actionQ, PerformGetNextPacket, new ActionLogging("GetNextPacket", ActionLoggingTraceReference));
        }

		#endregion

		//-----------------------------------------------------------------
		#region IPort action and abstract implementation methods (or abstract overrides to force passdown of abstract to derived class

        /// <summary>Base delegate method used to implement an IReadAction.  Resets the action.ParamValue, enqueues the action as a pending read action and services pending actions</summary>
		protected void PerformReadAction(IProviderActionBase<ReadActionParam, NullObj> action, out string resultCode)
		{
            action.ParamValue.Reset();

			pendingReadActionsQueue.Enqueue(action);

			ServicePendingActions();

			resultCode = null;		// no further action state changes are desired at this point
		}

        /// <summary>Base delegate method used to implement an IWriteAction.  Resets the action.ParamValue, enqueues the action as a pending write action and services pending actions</summary>
        protected void PerformWriteAction(IProviderActionBase<WriteActionParam, NullObj> action, out string resultCode)
		{
			action.ParamValue.Reset();

			pendingWriteActionsQueue.Enqueue(action);

			ServicePendingActions();

			resultCode = null;		// no further action state changes are desired at this point
		}

        /// <summary>Base delegate method used to implement an IFlushAction.  Calls HandleFlush method to perform the actual work.</summary>
        protected void PerformFlushAction(IProviderActionBase<TimeSpan, NullObj> action, out string resultCode)
		{
            TimeSpan flushPeriod = action.ParamValue;
            if (flushPeriod.IsZero())
                flushPeriod = PortConfig.IdleTime + (0.1).FromSeconds();

            resultCode = HandleFlush("Flush", flushPeriod);
		}

        /// <summary>
        /// Base delegate method used to implement an IGetNextPacketAction.  
        /// If the port has a sliding buffer then the method obtains the next packet (or null if there none) from the sliding buffer and sets the action result to contain it.
        /// If the port does not have a sliding buffer then the action fails with an appropriate error message.
        /// </summary>
        protected void PerformGetNextPacket(IProviderActionBase<NullObj, Packet> action, out string resultCode)
        {
            if (HasSlidingBuffer)
            {
                string actionDescription = "GetNextPacket";

                UpdateNumberOfPacketsAvailable(Math.Max(0, slidingPacketBuffer.NumPacketsReady - 1));
                Packet p = slidingPacketBuffer.GetNextPacket();

                if (p != null)
                    GenerateDataTrace(TraceDataEvent.Packet, actionDescription, "Type:{0}".CheckedFormat(p.Type), p.ErrorCode, p.Data, 0, p.Data.Length);
                else
                    GenerateDataTrace(TraceDataEvent.Packet, actionDescription, null, "no packet available", null, 0, 0);

                action.ResultValue = p;
                resultCode = string.Empty;
            }
            else
            {
                action.ResultValue = null;
                resultCode = "Invalid: Port configuration does not support auto rx packetization";
            }
        }

        /// <summary>Base delegate method used to implement GoOnline(andInitialize) actions.</summary>
        protected override string PerformGoOnlineAction(bool andInitialize)
		{
			string actionDescription = (andInitialize ? "GoOnlineAndInitialize" : "GoOnline");

			SetBaseState(UseState.AttemptOnline, actionDescription + ".Start", true);

            if (andInitialize || !BaseState.IsConnected)
                Log.Debug.Emit("Initiating connection for spec [{0}]", PortConfig.SpecStr);

			string rc = InnerPerformGoOnlineAction(actionDescription, andInitialize);

			if (string.IsNullOrEmpty(rc) && InnerReadBytesAvailable != 0)
				HandleFlush(actionDescription, (0.100).FromSeconds());

			bool success = string.IsNullOrEmpty(rc);

			if (success && !InnerIsConnected && !BaseState.IsConnecting)
			{
				rc = "Internal:PortNotConnectedAfterInnerGoOnlineSucceeded";
				success = false;
			}

			if (success)
				SetBaseState(UseState.Online, "{0} Done".CheckedFormat(actionDescription), true);
			else if (PortConfig.EnableAutoReconnect)
                SetBaseState(UseState.OnlineFailure, "{0} Failed (will attempt auto reconnect)".CheckedFormat(actionDescription), true);
            else
                SetBaseState(UseState.AttemptOnlineFailed, "{0} Failed".CheckedFormat(actionDescription), true);

			return (success ? string.Empty : rc);
		}

        /// <summary>Base delegate method used to implement GoOffline actions.</summary>
        protected override string PerformGoOfflineAction()
		{
			string actionDescription = "GoOffline";

            string rc = InnerPerformGoOfflineAction(actionDescription);
			bool success = string.IsNullOrEmpty(rc);

			if (success && InnerIsConnected)
			{
				rc = "Internal:PortStillConnectedAfterInnerGoOfflineSucceeded";
				success = false;
			}

			if (success)
				SetBaseState(UseState.Offline, "{0}.Inner.Done".CheckedFormat(actionDescription), true);
			else
                SetBaseState(UseState.Offline, "{0}.Inner.Failed".CheckedFormat(actionDescription), true);

			return (success ? string.Empty : rc);
		}

        /// <summary>Overrides default SimpleActivePart MainThreadFcn main loop method.  Allows this object to go offline automatically if the part is shutdown while online/connected.</summary>
        protected override void MainThreadFcn()
        {
            base.MainThreadFcn();

            if (PrivateBaseState.IsOnline)
                PerformGoOfflineAction();
        }

        /// <summary>custom Main Loop Service method.  Services pending actions and port state.</summary>
        protected override void PerformMainLoopService()
		{
			ServicePendingActions();

			ServicePortState();
		}

		#endregion

		//-----------------------------------------------------------------
		#region Other abstract utility methods to be implemented by a sub-class

        /// <summary>Abstract method used so that derived class can perform port type specific actions when the port is going online.  Returns empty string on success or non-empty string on failure.</summary>
		protected abstract string InnerPerformGoOnlineAction(string source, bool andInitialize);

        /// <summary>Abstract method used so that derived class can perform port type specific actions when the port is going offline.  Returns empty string on success or non-empty string on failure.</summary>
        protected abstract string InnerPerformGoOfflineAction(string source);

        /// <summary>Abstract getter property.  Returns the number of bytes that are currently available to be read or zero if there are none.</summary>
        protected abstract int InnerReadBytesAvailable { get; }

        /// <summary>Virtual getter property.  Returns the number of bytes in the write buffer that are currently used so as to allow the port to block issuing write actions when there is insufficient space.  base class implementation returns 0.</summary>
        protected virtual int InnerWriteSpaceUsed { get { return 0; } }

        /// <summary>Virtual getter property.  Returns the size of the write buffer, or zero if there is none.  base class implementation returns 0.</summary>
        protected virtual int InnerWriteSpaceAvailable { get { return 0; } }

        /// <summary>Virtual getter property.  Returns true if the InnerWriteSpaceUsed is less than the InnerWriteSpaceAvailable</summary>
        protected virtual bool InnerIsAnyWriteSpaceAvailable { get { return (InnerWriteSpaceUsed < InnerWriteSpaceAvailable); } }

        /// <summary>Abstract method that is implemented in the derived class to perform the low level reading of bytes from the port into the given buffer.  Method assigns the actual transfered count and the readResult</summary>
        protected abstract string InnerHandleRead(byte[] buffer, int startIdx, int maxCount, out int didCount, ref ActionResultEnum readResult);

        /// <summary>Abstract method that is implemented in the derived class to perform the low level writing of bytes to the port from the given buffer.  Method assigns the actual transfered count and the writeResult</summary>
        protected abstract string InnerHandleWrite(byte[] buffer, int startIdx, int count, out int didCount, ref ActionResultEnum writeResult);

        /// <summary>Abstract getter property.  Returns true if the underlying port is known to be connected or false otherwise.</summary>
        protected abstract bool InnerIsConnected { get; }

		#endregion

		//-----------------------------------------------------------------
		#region private and protected fields and related properties

        /// <summary>ActionLogging reference to be used for read, write, flush and get next packet actions.  resulting action logging will use the traceDataLogger.</summary>
        protected ActionLogging ActionLoggingTraceReference { get; private set; }

        /// <summary>ILogger that is used to all trace Data output.  Generally this is directed to a trace suitable logging group and set of corresponding log message handlers.</summary>
        protected readonly Logging.ILogger traceDataLogger = null;

        /// <summary>Logging.IMesgEmitter that is to be used for Error type messages</summary>
        protected readonly Logging.IMesgEmitter Error;
        /// <summary>Logging.IMesgEmitter that is to be used for Info type messages</summary>
        protected readonly Logging.IMesgEmitter Info;
        /// <summary>Logging.IMesgEmitter that is to be used for Debug type messages</summary>
        protected readonly Logging.IMesgEmitter Debug;
        /// <summary>Logging.IMesgEmitter that is to be used for Trace type messages</summary>
        protected readonly Logging.IMesgEmitter Trace;
        /// <summary>Logging.IMesgEmitter that is to be used for TraceData type messages</summary>
        protected readonly Logging.IMesgEmitter TraceData;

        /// <summary>Gives a queue of the current pending read actions</summary>
        protected Queue<IProviderActionBase<ReadActionParam, NullObj>> pendingReadActionsQueue = new Queue<IProviderActionBase<ReadActionParam, NullObj>>();
        /// <summary>Gives a queue of the current pending write actions</summary>
        protected Queue<IProviderActionBase<WriteActionParam, NullObj>> pendingWriteActionsQueue = new Queue<IProviderActionBase<WriteActionParam, NullObj>>();

        /// <summary>Returns true if the pendingReadActionQueue is not empty or the pendingWriteActionsQueue is not empty.</summary>
        protected bool AreAnyActionsPending { get { return (pendingReadActionsQueue.Count != 0 || pendingWriteActionsQueue.Count != 0); } }

		private byte [] flushBuf = new byte [512];

        private volatile int volatileNumberOfPacketsAvailable = 0;
		private SlidingPacketBuffer slidingPacketBuffer = null;
		private bool HasSlidingBuffer { get { return (slidingPacketBuffer != null); } }

		#endregion

		//-----------------------------------------------------------------
		#region Common utility methods

        /// <summary>Services the two pending actions queues.  Also checks if actions should be canceled due to the Base UseState and Base ConnState or when the InnerIsConnected property is false.</summary>
        protected void ServicePendingActions()
        {
            if (AreAnyActionsPending)
            {
                if (!BaseState.IsOnline)
                {
                    CancelPendingActions("Port is not online");
                    return;
                }

                if (!BaseState.IsConnected)
                {
                    CancelPendingActions("Connection is not ready");
                    return;
                }

                if (!InnerIsConnected)
                {
                    CancelPendingActions("Connection is not ready (internal)");
                    return;
                }
            }

            if (AreAnyActionsPending || HasSlidingBuffer)
            {
                QpcTimeStamp now = QpcTimeStamp.Now;

                ServicePendingWriteActions(now);
                ServicePendingReadActions(now);
            }
        }

		protected void ServicePendingReadActions(QpcTimeStamp now)
		{
            ActionResultEnum readResult = ActionResultEnum.None;

            if (HasSlidingBuffer)
			{
				// read characters into the sliding buffer

				int rxBytesAvail = InnerReadBytesAvailable;

				if (rxBytesAvail > 0)
				{
					byte [] buffer = null;
					int nextPutIdx = 0, spaceRemaining = 0;

					slidingPacketBuffer.GetBufferPutAccessInfo(128, out buffer, out nextPutIdx, out spaceRemaining);

					int didCount = 0;
                    string ec = HandleRead("BufRead", buffer, nextPutIdx, spaceRemaining, out didCount, ref readResult);

                    if (didCount > 0)
                    {
                        slidingPacketBuffer.AddedNChars(didCount);
                    }

                    if (!string.IsNullOrEmpty(ec) && BaseState.ConnState != ConnState.ConnectionFailed)
                    {
                        // only mark that the connection has failed if a lower level has not already done this (preserve its reason string).
                        // this is only done for connections with a SlidingBuffer since other connectsion can decide when to go offline or 
                        // reset the connection during their normal handling of completed actions.

                        this.SetBaseState(ConnState.ConnectionFailed, ec, true);
                    }
				}

                slidingPacketBuffer.Service();
                UpdateNumberOfPacketsAvailable(slidingPacketBuffer.NumPacketsReady);
			}

			while (pendingReadActionsQueue.Count > 0)
			{
				IProviderActionBase<ReadActionParam, NullObj> rdAction = pendingReadActionsQueue.Peek();
				ReadActionParam rdActionParam = rdAction.ParamValue;

				if (!rdActionParam.HasBeenStarted)
					rdActionParam.Start();

				if (rdAction.IsCancelRequestActive)
				{
                    // read action cancel has been requested before we have attempted to complete it through other means.
					rdActionParam.ActionResultEnum = ActionResultEnum.ReadCanceled;
					rdAction.CompleteRequest(rdActionParam.ResultCode = "Action Canceled by request");
					pendingReadActionsQueue.Dequeue();
					continue;
				}

				int gotCount = 0;
				string ec = null;

				if (HasSlidingBuffer)
				{
                    int numPacketsReady = slidingPacketBuffer.NumPacketsReady;
                    if (numPacketsReady > 0)
                    {
                        UpdateNumberOfPacketsAvailable(numPacketsReady - 1);

                        Packet p = slidingPacketBuffer.GetNextPacket();

                        if (p == null)
                            ec = "Internal: SB.HasPacket and packet was null";
                        else if (!String.IsNullOrEmpty(p.ErrorCode))
                            ec = p.ErrorCode;

                        int copyCount = (p.Data != null ? p.Data.Length : 0);
                        if (copyCount > rdActionParam.BytesToRead)
                        {
                            if (ec == null)
                                ec = Utils.Fcns.CheckedFormat("Read error: read in packet mode where target buffer size:{0} less than packet data size:{1}", rdActionParam.BytesToRead, copyCount);
                            copyCount = rdActionParam.BytesToRead;
                        }

                        if (copyCount > 0)
                            System.Buffer.BlockCopy(p.Data, 0, rdActionParam.Buffer, 0, copyCount);
                        gotCount = copyCount;
                    }
                    else
                    {
                        UpdateNumberOfPacketsAvailable(0);
                    }
				}
				else
				{
					int rxBytesAvail = InnerReadBytesAvailable;

					if (rxBytesAvail > 0)
					{
						int rdBytes = Math.Min(rxBytesAvail, (rdActionParam.BytesToRead - rdActionParam.BytesRead));

                        ec = HandleRead("Read", rdActionParam.Buffer, rdActionParam.BytesRead, rdBytes, out gotCount, ref readResult);
					}
				}

				if (gotCount > 0)
					rdActionParam.BytesRead += gotCount;

                bool readComplete = (rdActionParam.WaitForAllBytes ? (rdActionParam.BytesRead >= rdActionParam.BytesToRead) : (gotCount > 0));
                if (ec == null && (readResult != ActionResultEnum.None && readResult != ActionResultEnum.ReadDone && readResult != ActionResultEnum.ReadRemoteEndHasBeenClosed))
                    ec = Fcns.CheckedFormat("HandleRead gave: {0}", readResult);
				if (ec == null && readComplete)
					ec = string.Empty;

				TimeSpan elapsed = now - rdActionParam.StartTime;
				bool readTimeout = elapsed > PortConfig.ReadTimeout;

				if (ec == null && readTimeout)
					ec = Utils.Fcns.CheckedFormat("Read failed: timeout after {0} sec, got {1} of {2} bytes", elapsed.TotalSeconds, rdActionParam.BytesRead, rdActionParam.BytesToRead);

                if (ec != null)
                {
                    if (!rdAction.ActionState.IsIssued)
                    {
                        // do not attempt to process this read action further if it is no longer in the Issued state as it may have been aborted/completed elsewhere already, and in which case
                        // it has already been removed from the pendingReadActionsQueue
                        Log.Trace.Emit("current read action has been completed elsewhere.  Skipping post read completion: '{0}'", ec);
                    }
                    else
                    {
                        bool readSuccess = (ec == string.Empty);

                        if (readResult == ActionResultEnum.None)
                            rdActionParam.ActionResultEnum = (readSuccess ? ActionResultEnum.ReadDone : (readTimeout ? ActionResultEnum.ReadTimeout : ActionResultEnum.ReadFailed));
                        else
                            rdActionParam.ActionResultEnum = readResult;

                        rdAction.CompleteRequest(rdActionParam.ResultCode = ec);
                        pendingReadActionsQueue.Dequeue();
                        continue;
                    }
                }

				break;
			}
		}

        private const bool notifyBaseStateOnAllChangesInNumberOfPacketsAvailable = false;

        private void UpdateNumberOfPacketsAvailable(int numberOfPacketsAvailable)
        {
            if (volatileNumberOfPacketsAvailable != numberOfPacketsAvailable)
            {
                bool valueIncreased = (numberOfPacketsAvailable > volatileNumberOfPacketsAvailable);
                volatileNumberOfPacketsAvailable = numberOfPacketsAvailable;

                if (valueIncreased || notifyBaseStateOnAllChangesInNumberOfPacketsAvailable)
                    NotifyBaseStateNotifier();
            }
        }

        protected void ServicePendingWriteActions(QpcTimeStamp now)
		{
			while (pendingWriteActionsQueue.Count > 0)
			{
				IProviderActionBase<WriteActionParam, NullObj> wrAction = pendingWriteActionsQueue.Peek();
				WriteActionParam wrActionParam = wrAction.ParamValue;

				if (!wrActionParam.HasBeenStarted)
					wrActionParam.Start();

				if (wrAction.IsCancelRequestActive)
				{
					wrActionParam.ActionResultEnum = ActionResultEnum.WriteCanceled;
					wrAction.CompleteRequest(wrActionParam.ResultCode = "Action Canceled by request");
					pendingWriteActionsQueue.Dequeue();
					continue;
				}

				// write more bytes if possible
				string ec = null;
				bool isAnyTxSpaceAvailable = false;
                ActionResultEnum writeResult = ActionResultEnum.None;

				if (isAnyTxSpaceAvailable = InnerIsAnyWriteSpaceAvailable)
				{
					int bytesToTx = wrActionParam.BytesToWrite - wrActionParam.BytesWritten;
					int didCount = 0;

					if (bytesToTx > 0)
					{
						ec = HandleWrite("Write", wrActionParam.Buffer, wrActionParam.BytesWritten, bytesToTx, out didCount, ref writeResult);

						if (didCount > 0)
							wrActionParam.BytesWritten += didCount;
					}

					bool bufferWriteComplete = (wrActionParam.BytesWritten >= wrActionParam.BytesToWrite);

					byte [] txTermBytes = portConfig.TxLineTermBytes;
					int didTermCount = wrActionParam.BytesWritten - wrActionParam.BytesToWrite;
					int termBytesToGo = txTermBytes.Length - didTermCount;

					bool writeComplete = (wrActionParam.BytesWritten >= (wrActionParam.BytesToWrite + txTermBytes.Length));

					bytesToTx = termBytesToGo;

					isAnyTxSpaceAvailable = InnerIsAnyWriteSpaceAvailable;

					if (string.IsNullOrEmpty(ec) && bufferWriteComplete && !writeComplete && isAnyTxSpaceAvailable)
					{
						// write the line termination. - Keep trying until all of it has been written
						ec = HandleWrite("Write", txTermBytes, didTermCount, bytesToTx, out didCount, ref writeResult);
						if (didCount > 0)
							wrActionParam.BytesWritten += didCount;

						writeComplete = (wrActionParam.BytesWritten >= (wrActionParam.BytesToWrite + txTermBytes.Length));
					}

					bool writeFailed = !string.IsNullOrEmpty(ec);
                    if (writeComplete || writeFailed || writeResult != ActionResultEnum.None)
					{
                        bool actionStillActive = wrAction.ActionState.IsIssued;      // it may alredy have been canceled in some cases
                        if (actionStillActive)
                        {
                            if (writeResult == ActionResultEnum.None)
                                wrActionParam.ActionResultEnum = writeFailed ? ActionResultEnum.WriteFailed : ActionResultEnum.WriteDone;
                            else
                                wrActionParam.ActionResultEnum = writeResult;

                            wrAction.CompleteRequest(wrActionParam.ResultCode = Utils.Fcns.MapNullToEmpty(ec));
                        }

                        // attempt to dequeue the write action that we Peeked above.  If the queue is empty at this point, do not complain as logic in HandleWrite may have already cleared the queue.
                        if (pendingWriteActionsQueue.Count > 0)
                            pendingWriteActionsQueue.Dequeue();

                        continue;
					}
				}

				// check for timeout
				TimeSpan elapsed = now - wrActionParam.StartTime;

				if (wrActionParam.IsNonBlocking)
					ec = Utils.Fcns.CheckedFormat("Write failed: would block len:{0} space:{1}", wrActionParam.BytesToWrite, isAnyTxSpaceAvailable);
				else if (elapsed > portConfig.WriteTimeout)
					ec = Utils.Fcns.CheckedFormat("Write failed: timeout after {0} sec.  did {1} of {2} bytes", elapsed.TotalSeconds.ToString("f6"), wrActionParam.BytesWritten, wrActionParam.BytesToWrite);

                if (!string.IsNullOrEmpty(ec) && wrAction.ActionState.IsIssued)
				{
					wrActionParam.ActionResultEnum = ActionResultEnum.WriteFailed;
					wrAction.CompleteRequest(wrActionParam.ResultCode = ec);
					pendingWriteActionsQueue.Dequeue();
					continue;
				}

				break;
			}
		}

		protected virtual void ServicePortState()
		{
			IBaseState baseState = PrivateBaseState;

			if (baseState.IsConnected && !InnerIsConnected)
			{
				SetBaseState(ConnState.ConnectionFailed, "Connection Lost", true);
				return;
			}

			if (!baseState.IsOnline || !PortConfig.EnableAutoReconnect)
				return;

            // we can attempt a reconnect from the ConnectFailed, ConnectionFailed or the DisconnectedByOtherEnd states.
			bool stateSupportsAutoReconnect = ((baseState.ConnState == ConnState.ConnectFailed) 
                                               || (baseState.ConnState == ConnState.ConnectionFailed) 
                                               || (baseState.ConnState == ConnState.DisconnectedByOtherEnd)
                                               );
			TimeSpan timeInState = QpcTimeStamp.Now - baseState.TimeStamp;

			if (stateSupportsAutoReconnect && timeInState > PortConfig.ReconnectHoldoff)
			{
				InnerPerformGoOnlineAction("AutoReconnect", true);
			}
		}

		protected string HandleFlush(string source, TimeSpan timeLimit)
		{
			if (AreAnyActionsPending)
				CancelPendingActions("{0} was requested".CheckedFormat(source));

            // flush the sliding buffer first.
            if (HasSlidingBuffer && ((slidingPacketBuffer.BufferDataCount > 0) || slidingPacketBuffer.NumPacketsReady > 0))
            {
                // first extract and record the set of flushed packets from the sliding buffer.
                for (; ; )
                {
                    slidingPacketBuffer.Service();
                    UpdateNumberOfPacketsAvailable(Math.Max(0, slidingPacketBuffer.NumPacketsReady - 1));
                    Packet p = slidingPacketBuffer.GetNextPacket();
                    if (p != null && !p.IsNullOrNoneOrEmptyData)
                        GenerateDataTrace(TraceDataEvent.Flush, source, "PacketType:{0}".CheckedFormat(p.Type), String.Empty, p.Data, 0, p.Data.Length);
                    else
                        break;
                }

                // then flush any remaining data from the buffer.
                if (slidingPacketBuffer.BufferDataCount > 0)
                {
                    byte[] buffer;
                    int getIdx, getCount;
                    slidingPacketBuffer.GetBufferGetAccessInfo(out buffer, out getIdx, out getCount);
                    GenerateDataTrace(TraceDataEvent.Flush, source, "from sliding buffer", String.Empty, buffer, getIdx, getCount);
                    UpdateNumberOfPacketsAvailable(0);
                    slidingPacketBuffer.FlushBuffer();
                }
            }

			// need to flush line buffer if this port is using one

			QpcTimeStamp actionStartTime = QpcTimeStamp.Now;
			QpcTimeStamp idleStartTime = actionStartTime;
			bool portIsIdle = false;
			bool portWasIdle = false;
			bool idleTimeReached = false;
			int didCount = 0;
            string rc = string.Empty;

			for (; ; )
			{
				QpcTimeStamp now = QpcTimeStamp.Now;
                ActionResultEnum readResult = ActionResultEnum.None;
				rc = HandleRead(source, flushBuf, 0, flushBuf.Length, out didCount, ref readResult);
				bool success = string.IsNullOrEmpty(rc);
                bool forceFlushDone = (readResult != ActionResultEnum.None && readResult != ActionResultEnum.ReadDone);

				portIsIdle = (didCount == 0);

				if (!portWasIdle && portIsIdle)
					idleStartTime = QpcTimeStamp.Now;
				else
					idleTimeReached = (now - idleStartTime) > PortConfig.IdleTime;

                if (!success || idleTimeReached || forceFlushDone)
                    break;

				if ((now - actionStartTime) > timeLimit)
				{
					if (!portIsIdle)
						rc = "{0}: time limit reached before port fully idle".CheckedFormat(source);

					break;
				}

				WaitForSomethingToDo(TimeSpan.FromMilliseconds(10));		// check at 100 Hz nominal rate.
			}

            return rc;
		}

        protected string HandleRead(string source, byte[] buffer, int startIdx, int maxCount, out int didCount, ref ActionResultEnum readResult)
		{
			string rc = InnerHandleRead(buffer, startIdx, maxCount, out didCount, ref readResult);

			GenerateDataTrace(TraceDataEvent.Read, source, null, rc, buffer, startIdx, didCount);

			return (string.IsNullOrEmpty(rc) ? string.Empty : rc);
		}

		protected string HandleWrite(string source, byte [] buffer, int startIdx, int count, out int didCount, ref ActionResultEnum writeResult)
		{
            string rc = InnerHandleWrite(buffer, startIdx, count, out didCount, ref writeResult);

            GenerateDataTrace(TraceDataEvent.Write, source, null, rc, buffer, startIdx, didCount);

			return (string.IsNullOrEmpty(rc) ? string.Empty : rc);
		}

		protected void BaseStateChangedEventHandler(object source, IBaseState state)	// synchronously invoked during PublishBaseState, used to cancel pending actions on connection failure.
		{
			bool isConnectedOrConnecting = state.IsConnected || state.IsConnecting;

			if (!isConnectedOrConnecting && AreAnyActionsPending)
				CancelPendingActions(Utils.Fcns.CheckedFormat("Aborted because ConnState is {0}", state.ConnState));
		}

		protected void CancelPendingActions(string reason)
		{
			reason = Utils.Fcns.MapNullOrEmptyTo(reason, "[CancelReasonWasNotSpecified]");

			foreach (IProviderActionBase<ReadActionParam, NullObj> action in pendingReadActionsQueue)
			{
				action.ParamValue.ActionResultEnum = ActionResultEnum.ReadFailed;
				action.ParamValue.ResultCode = reason;
				action.CompleteRequest(reason);
			}

			pendingReadActionsQueue.Clear();

			foreach (IProviderActionBase<WriteActionParam, NullObj> action in pendingWriteActionsQueue)
			{
				action.ParamValue.ActionResultEnum = ActionResultEnum.WriteFailed;
				action.ParamValue.ResultCode = reason;
				action.CompleteRequest(reason);
			}

			pendingWriteActionsQueue.Clear();
		}

		private System.Text.StringBuilder traceSB = new System.Text.StringBuilder();

        private void GenerateDataTrace(TraceDataEvent traceDataEvent, string source, string detail, string resultCode, byte[] buffer, int startIdx, int count)
        {
            if (!TraceData.IsEnabled || ((traceDataEventMask & traceDataEvent) == 0) || (traceDataFormat == TraceDataFormat.None))
                return;

            string mesg = null;

            bool useNewStyle = (traceDataFormat != TraceDataFormat.OldXmlishStyle);
            bool includeDottedAscii = ((traceDataFormat & TraceDataFormat.IncludeDottedAscii) != 0);
            bool includeEscapedAscii = ((traceDataFormat & TraceDataFormat.IncludeEscapedAscii) != 0);
            bool includeHex = ((traceDataFormat & TraceDataFormat.IncludeHex) != 0);
            bool useMessageDataField = ((traceDataFormat & TraceDataFormat.UseMessageDataField) != 0);

            try
            {
                traceSB.Length = 0;	// clear the string

                if (useNewStyle)
                {
                    traceSB.CheckedAppendFormat("DataTrace {0}", traceDataEvent);

                    if (!source.IsNullOrEmpty())
                        traceSB.CheckedAppendFormat(" src:{0}", source);

                    if (!detail.IsNullOrEmpty())
                        traceSB.CheckedAppendFormat(" detail:[{0}]", detail.GenerateSquareBracketEscapedVersion(escapeChar: traceDataAsciiEscapeChar));

                    traceSB.CheckedAppendFormat(" count:{0}", count);

                    if (includeEscapedAscii)
                        traceSB.CheckedAppendFormat(" ascii:[{0}]", ByteArrayTranscoders.ByteStringTranscoder.Encode(buffer, startIdx, count).GenerateSquareBracketEscapedVersion(escapeChar: traceDataAsciiEscapeChar));

                    if (!resultCode.IsNullOrEmpty())
                        traceSB.CheckedAppendFormat(" rc:[{0}]", resultCode.GenerateSquareBracketEscapedVersion(escapeChar: traceDataAsciiEscapeChar));
                }
                else
                {
                    traceSB.CheckedAppendFormat("<DataTrace action=\"{0}\" count=\"{1}\" rc=\"{2}\" event=\"{3}\" detail=\"{4}\">",
                                            source, count,
                                            (string.IsNullOrEmpty(resultCode) ? "" : resultCode), traceDataEvent, detail);
                }

                if (includeDottedAscii || includeHex)
                {
                    const int maxSectionSize = 64;

                    for (int idx = 0, endIdx = startIdx + count, segment = 1; startIdx < endIdx; segment++)
                    {
                        int sectionCount = System.Math.Min(maxSectionSize, endIdx - startIdx);
                        int sectionEndIdx = startIdx + sectionCount;

                        if (useNewStyle)
                            traceSB.CheckedAppendFormat(" segment:{0}", segment);

                        if (includeDottedAscii)
                        {
                            traceSB.CheckedAppendFormat(useNewStyle ? " ascii_dotted:{0}:[" : "<ascii n=\"{0}\">", sectionCount);

                            for (idx = startIdx; idx < sectionEndIdx; idx++)
                            {
                                Char c = (Char)buffer[idx];
                                bool dotChar = !(Char.IsLetterOrDigit(c) || Char.IsPunctuation(c) || c == ' ');

                                traceSB.Append(dotChar ? '.' : c);
                            }

                            traceSB.Append(useNewStyle ? "]" : "</ascii>");
                        }

                        if (includeHex)
                        {
                            traceSB.CheckedAppendFormat(useNewStyle ? "hex:{0}:[" : "<hex n=\"{0}\">", sectionCount);

                            for (idx = startIdx; idx < sectionEndIdx; idx++)
                            {
                                byte b = buffer[idx];
                                traceSB.Append(b.ToString("x2"));
                            }

                            traceSB.AppendFormat(useNewStyle ? "]" : "</hex>");
                        }

                        startIdx += sectionCount;
                    }
                }

                if (!useNewStyle)
                    traceSB.Append("</DataTrace>");

                mesg = traceSB.ToString();
            }
            catch (System.Exception ex)
            {
                mesg = "GenerateDataTrace failed:{0}".CheckedFormat(ex.ToString(ExceptionFormat.TypeAndMessage));
            }

            if (useMessageDataField)
                TraceData.EmitWith(mesg, data: buffer.SafeSubArray(startIdx, count));
            else
                TraceData.Emit(mesg);
        }

		#endregion

		//-----------------------------------------------------------------
	}

	#endregion

	//-----------------------------------------------------------------
	#region NullPort

	public class NullPort : PortBase
	{
		public NullPort(PortConfig portConfig) 
            : base(portConfig, "NullPort")
        {
            PortBehavior = new PortBehaviorStorage() { DataDeliveryBehavior = DataDeliveryBehavior.None };
        }

		protected override string InnerPerformGoOnlineAction(string actionName, bool andInitialize)
		{
			SetBaseState(UseState.Online, ConnState.Connected, actionName + ":Done", true);
			return string.Empty;
		}

		protected override string InnerPerformGoOfflineAction(string actionName)
		{
			SetBaseState(UseState.Offline, ConnState.Disconnected, actionName + ":Done", true);
			return string.Empty;
		}

		protected override int InnerReadBytesAvailable
		{
			get { return 0; }
		}

		protected override string InnerHandleRead(byte [] buffer, int startIdx, int maxCount, out int didCount, ref ActionResultEnum readResult)
		{
			didCount = 0;
			return string.Empty;
		}

        protected override string InnerHandleWrite(byte[] buffer, int startIdx, int count, out int didCount, ref ActionResultEnum writeResult)
		{
			didCount = count;
			return string.Empty;
		}

		protected override bool InnerIsConnected
		{
			get { return BaseState.IsConnected; }
		}
	}
	#endregion

	//-----------------------------------------------------------------
}
